# Report

Mattia Marziali (S5127742) & Denisa Neagu (S5124662)

## Introduction

> Our program is a simple RTS game simulator which allows people to create their own maps, place units, and then simulate the game step by step to see how it evolves. The program also has a multiplayer mode, in which players take turns trying to conquer each other's starting nodes as well as balancing resources and units throughout the game.

## Program design

> *Here you go over the structure of the program. Try not to go too in-depth here implementation-wise, but rather discuss the important components and relations between them. 
> If you think it can help, feel free to add a simple diagram here. The design of the program should be clear to the reader. 
> 
> In particular, describe the model of the program. How is it structured? How did you make sure to separate the different aspects of the program?
> How do the `model`, `view` and `controller` interact with each other?
> Additionally, you should include some design decisions in here. There is no need to provide an explanation for every single thing, 
> but there are often multiple ways of implementing a feature and in those cases it makes sense to state why you chose one over the other.*

> Expected length: as much as you need to explain the above.

## The singleplayer mode

The singleplayer mode was implemented using the classic MVC pattern. One of the tricks we used to reduce boilerplate throughout our code was to coincide interface names with Lombok autogenerated methods in such a way that we would not have to write them multiple times. Specifically, this was implemented in anything which extends `Observable` as one of the methods needs to be named `getObservers` which was easily created by making a `observers` field and using Lombok.


## Handling JSON with Rugson

In order to handle JSON properly we decided to implement our own library entirely from scratch. The JSON parsing process consists of two steps: first, the JSON string is tokenized into a list of tokens, and then the tokens are parsed into a tree structure. The tree structure is then used to create the model. The reason for this is that the tree structure is much easier to work with than the token list, and it also allows us to easily check for errors in the JSON file. The tree structure is also used to serialize the model back into a JSON string.

To be able to deal with multiple classes being thrown in the JSON serialized we opted to use a pluggable model, where each class type would be registered with the parser (within the `RugsonBuilder`), and would then handle the object creation itself. This allowed us to easily add new classes to the parser without having to modify the parser itself. 

Finally, if a class is not registered within the parser, it will be converted into a JSON structure using reflection. This allows us to avoid having to write a serializer for each class, however it comes at the cost of some level of performance (as reflection can be slow at times), and it also means that an empty public constructor for the class needs to be readily accesible (so that the parser can create an instance of the class).

As a final note, when dealing with JSON it is extremely important to take great care to handle generics, especially as type erasure makes it a tricky to navigate, as well as taking into account classes which extend other classes and also handle these properties properly.

## Handling Networking

When it comes to networking we decided to write a simple full protocol from scratch using TCP. 

A possible candidate before taking this decision would have been HTTP as it is a well known protocol which is also supported by Java, however we decided against it as it would cause latency issues due to the fact that it is a stateless protocol and would require us to either open a connection every time we wanted to send a message, or to keep a connection open at all times with polling.

Considering that, we decided to come up with our own simple protocol. It involves a bidirectional connection which sends packets sequentially over the network. The first 4 bytes of the packet are used as the packet ID, and the next 4 bytes are used as the packet length. The packet ID is used to identify the type of packet, and the packet length is used to determine how many bytes should be read from the stream.

Taking into account the fact that we have full control over the client and the server, both of them know the packet ID's in advance (see `RTSPacketDictionary`) and can therefore easily determine the type of packet they are dealing with. This allows us to easily add new packets to the protocol without having to worry about backwards compatibility.

These packets are then serialized and deserialized using Rugson, and while it's true that a JSON based approach is not necessarily the most efficient, it is extremely easy to work with and allows us to easily add new packets to the protocol without writing all that much extra code. 

Finally, in order to make sure that the connection is always alive, we exchange a small packet (see `KeepAlivePacket`) every couple of seconds. This allows us to easily detect when the connection is lost or if something went wrong. 

## The Server 

The server for the game is also built in Java, and it is a simple multithreaded server which listens for incoming connections and then creates a new thread for each client. The server is also responsible for handling the game logic, and it is the one which decides when the game is over. 

The Multiplayer logic is not entirely identical to the singleplayer one, specifically, each player is only able to add armies from their own team, events get used up instead of being permanent on the map, and the game ends if one of the players is able to get any army on the starting node of the other player. 

All of the server side data is stored in a MySQL database, with all password being hashed using SHA-256. (bCrypt would have been a better choice, however, in the spirit of the challenge, we wanted to use as little external sources as possible, and SHA is already built into Java). 

### A quick note about cheating and disruptive behaviour

In order to prevent desyncronization issues (as well as prevent cheating) all of the game logic is run on the server, with the clients only sending their actions to the server and then receiving the updated game state. This allows us to easily prevent cheating, as well as make sure that the game is always in sync. 

Furthermore, in order to make sure cheating is not possible in any way, as well as any potentially disruptive behaviour the server implements a chained listener approach, with any packets which are not expected being ignored. (see `AuthenticatedPacket`, `GameScopedPacket`, `LobbyScopedPacket`). As such, even if a player were to be able to somehow get the ID for another game, they would not be able to send any packets to interfere with it in any way. It should also be mentioned that the `AuthenticatedPacket` class does not bundle credentials inside of it, but rather contains a little token which is given to the client by the server upon successful authentication. This token is then used to identify the client, and it is also used to prevent replay attacks.



## Evaluation of the program

> *Discuss the stability of your implementation. What works well? Are there any bugs? Is everything tested properly? Are there still features that have not been implemented? Also, if you had the time, what improvements would you make to your implementation? Are there things which you would have done completely differently?*

### Stability

Stability was always on our mind while dealing with the project, especially when working on the multiplayer aspect of the game. That is why we decided to run the logic of the game on the server, and only send the actions of the players to the server. 

The game has also been thoroughly tested by multiple people and we have not encountered any bugs so far.
We took great care to ensure that the game is as stable as possible, mostly by properly separating the client, the server and following proper OOP principles. 

The list of improvements we would make to the game if we had more time is endless, however some notable ones would be:

- Using reflection is slow, and it would be better to write a serializer for each class. However, this would take a lot of time. A solution which would not compromise on either performance or time would be to take the approach which the Kryo serializer takes with bytecode generation. Specifically, using an ASM manipulation library (such as ASM, ByteBuddy or Javassist) to generate the serializer for all classes at runtime and dynamically inject them inside of the parser. This would allow us to have the best of both worlds, as we would not have to write the serializers ourselves, and we would also not have to use reflection (thus being insanely fast).

- Unit testing. Due to time constraints we were unable to write comprehensive unit tests for the game, and we would have liked to do so. If we were to in fact do it, we would pick JUnit (obviously), as well as Mockito for easy mocking of objects.

- Currently the game itself is fun for about 4 matches. To put it simply, both members of the team are programmers first and game designers second. As such we would have liked to look more into adding more fun features to the game, as well as *balancing* it properly. Specifically, we would have liked to add a campaign mode for the singleplayer rather than it essentially acting as a multiplayer game map editor. 

## Questions

Please answer the following questions:

1. In this assignment, the program should follow the Model View Controller (MVC) pattern. Please explain the design of the program in terms of the MVC pattern. Specifically try to answer the following questions:
   - MVC consists of three components: Model, view and controller. Can you please explain the role of each component? Please provide examples of these roles from the assignment. How are these three roles (i.e. Model, view and controller) are implemented in the assignment?
   - MVC enforces special constraints on the dependencies between its three components: Model, view and controller. Please explain these constraints, and why are they important?

___

Answer:

1. Model represents the data of the application. Specifically, in this assignment we consider the classes as `Node` and `Edge` as representatives for the Model.

2. The controller is where most of the logic of the application is implemented. In this assignment we consider something like a `MapSimulationController` as one of the controllers.
 
3. The view is the part of the application which is responsible for displaying the data to the user. In this assignment we consider the `MapView` as a possible view.


The constraints which MVC places on the dependencies between the three components are as follows:
- The model is not allowed to know anything about the view or the controller.
- The view is not allowed to know anything about the controller.
- The controller is not allowed to know anything about the view.
- The view is allowed to know about the model, but only in a read-only fashion.

These constraints are important because they allow us to easily change the view or the controller without having to change the model, and vice-versa. This allows us to easily change the implementation of the view or the controller without having to worry about breaking the model. It also allows for the implementing of the observer pattern, which is useful to make sure that the view is always up to date with the model.

___

2. The Swing library provides the ability to create nested user interface components. In this assignment, you created multiple JPanel components on the user interface. These contain other user interface components to build-up a tree of user interface components.
Which design pattern does Swing implement to create a hierarchy of user interface components? Please explain this pattern and how it is implemented in Swing.

___

Answer:

The Swing library implements the Composite pattern. The Composite pattern is a structural design pattern which allows us to treat a group of objects in the same way as a single object. In the case of Swing, the `JPanel` class is the composite, and the `JButton` class is the leaf. This allows us to treat a group of buttons as a single object, and thus allows us to easily add multiple buttons to a panel.

___

3. The Observer pattern is useful to implement the MVC pattern. Can you please explain the relationship between the Observer pattern and the MVC pattern?
Please provide an example from the assignment on how the Observer pattern supports implementing the MVC pattern.

___

Answer:
The Observer pattern is useful to implement the MVC pattern because it allows us to easily update the view whenever the model changes. This is done by having the view implement the `Observer` interface, and then having the model implement the `Observable` interface. This allows us to easily update the view whenever the model changes, as well as easily add new views to the model.

___

## Process evaluation

> *Describe shortly the process that led to the final code and the report. What was easy, what was difficult? Did you make interesting mistakes? What have you learned from this assignment?*

One of the most successful things we did was rounds of testing. Specifically, we assembled a group of people and had them play the game, and then we would ask them for feedback. This allowed us to easily find bugs, as well as get feedback on the game itself. After doing this a few times, we were able to get a good idea of what the game was missing, and what we should add to it, as well as fix some of the bugs which we had missed.

One of the bugs we faced which was unexpected was that the type adapters for the `Event` class was not being initialized properly, but only when loading a custom map with events made in singleplayer into multiplayer. Having people help us with testing allowed us to find many edge cases we would not have otherwise found.

## Conclusions

Overall, we are very happy with the result of the project. We were able to implement all of the features we wanted to, and we were able to do so in a way which is stable and easy to maintain. 

We were also able to implement a multiplayer aspect to the game, which was one of the main goals of the project. (although largely outside of the assignment). 
